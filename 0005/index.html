<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>5.最长回文子串 | LeetCode题解</title>
    <meta name="description" content="用JS代码编写的LeetCode题解">
    <link rel="icon" href="https://github.githubassets.com/pinned-octocat.svg">
    
    <link rel="preload" href="/LeetCode/assets/css/0.styles.52c45855.css" as="style"><link rel="preload" href="/LeetCode/assets/js/app.643ee7bd.js" as="script"><link rel="preload" href="/LeetCode/assets/js/2.126f6435.js" as="script"><link rel="prefetch" href="/LeetCode/assets/js/10.1f81ca2e.js"><link rel="prefetch" href="/LeetCode/assets/js/11.25f638ee.js"><link rel="prefetch" href="/LeetCode/assets/js/12.f1531905.js"><link rel="prefetch" href="/LeetCode/assets/js/13.52d05087.js"><link rel="prefetch" href="/LeetCode/assets/js/14.d62131a3.js"><link rel="prefetch" href="/LeetCode/assets/js/15.6e38c344.js"><link rel="prefetch" href="/LeetCode/assets/js/16.42cd9980.js"><link rel="prefetch" href="/LeetCode/assets/js/17.cafca25f.js"><link rel="prefetch" href="/LeetCode/assets/js/18.f1f57acf.js"><link rel="prefetch" href="/LeetCode/assets/js/19.63867dbc.js"><link rel="prefetch" href="/LeetCode/assets/js/20.0fbf2035.js"><link rel="prefetch" href="/LeetCode/assets/js/21.80e26cff.js"><link rel="prefetch" href="/LeetCode/assets/js/22.029d38f4.js"><link rel="prefetch" href="/LeetCode/assets/js/23.b1ceefd5.js"><link rel="prefetch" href="/LeetCode/assets/js/24.1392faf7.js"><link rel="prefetch" href="/LeetCode/assets/js/25.cdd0201c.js"><link rel="prefetch" href="/LeetCode/assets/js/26.16e506b7.js"><link rel="prefetch" href="/LeetCode/assets/js/27.caf46eec.js"><link rel="prefetch" href="/LeetCode/assets/js/28.b12c3eb5.js"><link rel="prefetch" href="/LeetCode/assets/js/29.c75420b8.js"><link rel="prefetch" href="/LeetCode/assets/js/3.c41011a1.js"><link rel="prefetch" href="/LeetCode/assets/js/30.c04ae951.js"><link rel="prefetch" href="/LeetCode/assets/js/31.7aba6979.js"><link rel="prefetch" href="/LeetCode/assets/js/32.23d13260.js"><link rel="prefetch" href="/LeetCode/assets/js/33.76360cf7.js"><link rel="prefetch" href="/LeetCode/assets/js/34.11462fbe.js"><link rel="prefetch" href="/LeetCode/assets/js/35.9c21cf65.js"><link rel="prefetch" href="/LeetCode/assets/js/36.47da49e2.js"><link rel="prefetch" href="/LeetCode/assets/js/37.c9dc4b9b.js"><link rel="prefetch" href="/LeetCode/assets/js/4.99cf71fb.js"><link rel="prefetch" href="/LeetCode/assets/js/5.b2fccff6.js"><link rel="prefetch" href="/LeetCode/assets/js/6.fb9037bf.js"><link rel="prefetch" href="/LeetCode/assets/js/7.32e3d783.js"><link rel="prefetch" href="/LeetCode/assets/js/8.0f83d185.js"><link rel="prefetch" href="/LeetCode/assets/js/9.ed1098c1.js">
    <link rel="stylesheet" href="/LeetCode/assets/css/0.styles.52c45855.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/LeetCode/" class="home-link router-link-active"><!----> <span class="site-name">LeetCode题解</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/LeetCode/" class="nav-link">首页</a></div><div class="nav-item"><a href="/LeetCode/about/" class="nav-link">介绍</a></div><div class="nav-item"><a href="https://github.com/biaodigit" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/LeetCode/" class="nav-link">首页</a></div><div class="nav-item"><a href="/LeetCode/about/" class="nav-link">介绍</a></div><div class="nav-item"><a href="https://github.com/biaodigit" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/LeetCode/about/" class="sidebar-link">导读</a></li><li><a href="/LeetCode/0001/" class="sidebar-link">1.两数之和</a></li><li><a href="/LeetCode/0002/" class="sidebar-link">2.两数相加</a></li><li><a href="/LeetCode/0003/" class="sidebar-link">3.无重复字符的最长子串</a></li><li><a href="/LeetCode/0004/" class="sidebar-link">4.寻找两个有序数组的中位数</a></li><li><a href="/LeetCode/0005/" class="active sidebar-link">5.最长回文子串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/LeetCode/0005/#题目：最长回文子串" class="sidebar-link">题目：最长回文子串</a></li><li class="sidebar-sub-header"><a href="/LeetCode/0005/#解题思路1：中心扩展法" class="sidebar-link">解题思路1：中心扩展法</a></li><li class="sidebar-sub-header"><a href="/LeetCode/0005/#解题思路2：manacher算法" class="sidebar-link">解题思路2：Manacher算法</a></li><li class="sidebar-sub-header"><a href="/LeetCode/0005/#代码实现：中心扩展法" class="sidebar-link">代码实现：中心扩展法</a></li><li class="sidebar-sub-header"><a href="/LeetCode/0005/#代码实现：manacher算法" class="sidebar-link">代码实现：Manacher算法</a></li></ul></li><li><a href="/LeetCode/0006/" class="sidebar-link">6.Z 字形变换</a></li><li><a href="/LeetCode/0007/" class="sidebar-link">7.整数反转</a></li><li><a href="/LeetCode/0008/" class="sidebar-link">8.字符串转换整数 (atoi)</a></li><li><a href="/LeetCode/0009/" class="sidebar-link">9.回文数</a></li><li><a href="/LeetCode/0010/" class="sidebar-link">10.正则表达式匹配</a></li><li><a href="/LeetCode/0011/" class="sidebar-link">11.盛最多水的容器</a></li><li><a href="/LeetCode/0012/" class="sidebar-link">12.整数转罗马数字</a></li><li><a href="/LeetCode/0013/" class="sidebar-link">13.罗马数字转整数</a></li><li><a href="/LeetCode/0014/" class="sidebar-link">14.最长公共前缀</a></li><li><a href="/LeetCode/0015/" class="sidebar-link">15.三数之和</a></li><li><a href="/LeetCode/0016/" class="sidebar-link">16.最接近的三数之和</a></li><li><a href="/LeetCode/0017/" class="sidebar-link">17.电话号码的字母组合</a></li><li><a href="/LeetCode/0018/" class="sidebar-link">18.四数之和</a></li><li><a href="/LeetCode/0019/" class="sidebar-link">19.删除链表的倒数第N个节点</a></li><li><a href="/LeetCode/0020/" class="sidebar-link">20.有效的括号</a></li><li><a href="/LeetCode/0021/" class="sidebar-link">21.合并两个有序链表</a></li><li><a href="/LeetCode/0022/" class="sidebar-link">22.括号生成</a></li><li><a href="/LeetCode/0023/" class="sidebar-link">23.合并K个排序链表</a></li><li><a href="/LeetCode/0024/" class="sidebar-link">24.两两交换链表中的节点</a></li><li><a href="/LeetCode/0025/" class="sidebar-link">25.K 个一组翻转链表</a></li><li><a href="/LeetCode/0026/" class="sidebar-link">26.删除排序数组中的重复项</a></li><li><a href="/LeetCode/0027/" class="sidebar-link">27.移除元素</a></li><li><a href="/LeetCode/0028/" class="sidebar-link">28.实现 strStr()</a></li><li><a href="/LeetCode/0029/" class="sidebar-link">29.两数相除</a></li><li><a href="/LeetCode/0030/" class="sidebar-link">30.串联所有单词的子串</a></li><li><a href="/LeetCode/0031/" class="sidebar-link">31.下一个排列</a></li><li><a href="/LeetCode/0032/" class="sidebar-link">32.最长有效括号</a></li></ul> </div> <div class="page"> <div class="content"><h2 id="题目：最长回文子串"><a href="#题目：最长回文子串" aria-hidden="true" class="header-anchor">#</a> 题目：最长回文子串</h2> <p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p> <p><strong>示例 1</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
</code></pre></div><p><strong>示例 2</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;
</code></pre></div><p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/longest-palindromic-substring/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="解题思路1：中心扩展法"><a href="#解题思路1：中心扩展法" aria-hidden="true" class="header-anchor">#</a> 解题思路1：中心扩展法</h2> <p>首先要了解什么是回文串，通俗的话讲就是对称字符串，比如<code>aba</code>为回文串，<code>abba</code>也是回文串，因为它们在反转后仍然相等，即<br></p> <blockquote><p>str === str.reverse()</p></blockquote> <p>满足上诉条件就是回文串，而回文串又分为两种情况<br> <img src="/LeetCode/assets/img/0005-01.5c1ad5ab.png" alt="0005-01.png"><br>
如上图，当长度为奇数的时候中心为<code>a</code>，为偶数的时候中心是<code>a</code>和<code>a</code>的边界，因此在计算的时候就需要同时考虑两种情况<br>
首先定义<code>start</code>和<code>maxLen</code>，<code>start</code>用于记录最长回文串起点，<code>maxLen</code>用于记录最大长度
每次循环去执行一个函数，函数同时执行两次，传入中心点为<code>i</code>和<code>i</code>，<code>i</code>和<code>i+1</code><br> <img src="/LeetCode/assets/img/0005-02.58fb9388.png" alt="0005-02.png"><br>
如上图，以长度为奇数为例子，传入的<code>i</code>和<code>i</code>分别当作<code>l</code>和<code>r</code>，当<code>s[l]===s[r]</code>时，<code>l</code>移动至前一位，<code>r</code>移动至后一位，如下图
<img src="/LeetCode/assets/img/0005-03.eab3b1a9.png" alt="0005-03.png"><br>
继续比较<code>s[l]</code>和<code>s[r]</code>，相等则继续移动,如下图
<img src="/LeetCode/assets/img/0005-04.0623e727.png" alt="0005-04.png"><br>
继续比较,<code>s[l]!==s[r]</code>，退出循环<br>
然后与<code>maxLen</code>与<code>r-l-1</code>比较，如果后者更大则更新<code>maxLen</code>，同时更新<code>start</code>为<code>l+1</code></p> <h2 id="解题思路2：manacher算法"><a href="#解题思路2：manacher算法" aria-hidden="true" class="header-anchor">#</a> 解题思路2：Manacher算法</h2> <p>Manacher算法简介</p> <blockquote><p>[Manacher(1975)] 发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer &amp; Galil (1995) 发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决 Jeuring (1994), Gusfield (1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。</p></blockquote> <p>Manacher(又称&quot;马拉车&quot;)算法对比中心扩展法来看更可以认为是一种结合kmp的优化版，对比中心扩展法时间复杂度是<code>O(n^2)</code>,马拉车算法时间复杂度为<code>O(n)</code><br></p> <h4 id="第1步：添加分隔符"><a href="#第1步：添加分隔符" aria-hidden="true" class="header-anchor">#</a> 第1步：添加分隔符</h4> <p>中心扩展法需要同时计算奇数长度和偶数长度的中心，马拉车算法开始计算前在字符串中插入分隔符<code>#</code>,就可以把奇数长度和偶数长度的字符串全部整合为一种情况，如下:<br>
比如：</p> <ul><li>奇数长度：<code>bbbabbc</code> =====&gt; <code>#b#b#b#a#b#b#c#</code><br></li> <li>偶数长度：<code>cbbabb</code> =====&gt; <code>#c#b#b#a#b#b#</code><br></li></ul> <p>为什么需要加分隔符呢，简单做个计算：假如字符串长度是<code>len</code>,在每个字符前添加一个分隔符长度就会变为<code>2*len</code>，在字符串最后再加一个分隔符，长度就变为<code>2*len+1</code>，这样就确保字符串长度始终为奇数，可以不考虑之前偶数长度情况,往后计算会更加方便<br></p> <h4 id="第2步：建立p数组，得到任意字符串回文半径长度"><a href="#第2步：建立p数组，得到任意字符串回文半径长度" aria-hidden="true" class="header-anchor">#</a> 第2步：建立p数组，得到任意字符串回文半径长度</h4> <p>建立p数组的意义在于得到任意字符串回文半径长度，因为每一个字符串本身都个可以看作是一个回文字符，而较前位置的回文字符半径会被较后位置的回文字符复用(由于回文字符性质，前半部分存在的回文字符在后半部分同样存在)，因此复用半径可以直接减少<code>while</code>循环次数，直接降低时间复杂度<br></p> <p>以<code>cbbabb</code>为例，先画出下面的表格<br> <img src="/LeetCode/assets/img/0005-05.bac65054.png" alt="0005-05.png"><br>
首先定义如何计算回文半径：</p> <ul><li>从字符串开始计算，以当前扩展点为中心，最小半径为1，然后同时往左右进行中心扩展，直至不能扩展为止<br></li></ul> <p>首先计算<code>str[0]</code>，初始半径为1，然后进行中心扩展，结果都到了边界，因此<code>str[0]</code>半径为1<br> <img src="/LeetCode/assets/img/0005-06.c4d5999c.png" alt="0005-06.png"><br>
计算<code>str[1]</code>，同样初始化半径后中心扩展，<code>str[0]=str[2]</code>，半径加1，继续扩展到达边界<br> <img src="/LeetCode/assets/img/0005-07.57c52114.png" alt="0005-07.png"><br>
计算<code>str[2]</code>，左右扩展后到达边界<br> <img src="/LeetCode/assets/img/0005-08.1ec707ce.png" alt="0005-08.png"><br>
计算<code>str[3]</code>，左右扩展匹配，半径加1，继续扩展到达边界<br> <img src="/LeetCode/assets/img/0005-09.77bbf745.png" alt="0005-09.png"><br>
计算<code>str[4]</code>，左右扩展匹配，半径加1，继续扩展匹配，加1，继续扩展到达边界
<img src="/LeetCode/assets/img/0005-10.9f5480a8.png" alt="0005-10.png"><br>
最终计算完的p数组:<br> <img src="/LeetCode/assets/img/0005-11.a1606112.png" alt="0005-11.png"><br>
p-1数组<br> <img src="/LeetCode/assets/img/0005-12.4e3eb2d4.png" alt="0005-12.png"><br>
为什么还要p-1数组呢，这里简单分析下:<br>
1.已知长度为<code>n</code>的回文串添加分隔符后长度为<code>2n+1</code><br>
2.假设上面计算的中心半径为<code>p</code>，那么容易得出<code>2p-1</code> = <code>2n+1</code><br>
3.通过2可以算出<code>p = n+1 ===&gt; p-1 = n</code>,因此得到p-1数组即为回文串长度数组</p> <h4 id="第3步：如何在代码中计算p数组"><a href="#第3步：如何在代码中计算p数组" aria-hidden="true" class="header-anchor">#</a> 第3步：如何在代码中计算p数组</h4> <blockquote><p>以下图片为了方便理解把#符都省略掉</p></blockquote> <p>在第2步里介绍了马拉车算法核心在于复用回文串长度，在了解如何复用前先看下图:<br> <img src="/LeetCode/assets/img/0005-13.0a301700.png" alt="0005-13.png"><br>
从上图容易获得三个关键信息:<br></p> <ul><li><code>i</code>和<code>j</code>是关于<code>cid</code>中心对称的，容易得出<code>j</code>=<code>2*cid - id</code>的性质<br></li> <li>假设<code>mR</code>为最长回文串的最右边界，那么容易得出<code>cid+p[cid]-1 = mR</code><br></li> <li>假设以<code>i</code>为中心的字符串也是回文串且长度不超过<code>mR</code>，那么根据上图可以得出<code>i+p[i]-1&lt;=mR</code><br>
通过以上三个性质，先去计算最简单的一种情况:<br></li> <li>假如<code>i&lt;mR</code>，那么就可以考虑复用原则:<br> <ul><li>假如以<code>j</code>为中心的回文串长度不超过<code>cId</code>的半径,那么<code>p[i]=p[2*cid-j]</code>是成立的，如下图：<br> <img src="/LeetCode/assets/img/0005-15.0378bbe6.png" alt="0005-15.png"><br></li> <li>假如以<code>j</code>为中心的回文串长度超过左边界，大概情况如下图:<br> <img src="/LeetCode/assets/img/0005-14.98c6fc2c.png" alt="0005-14.png"><br>
从上图可以看出<code>j</code>的半径明显要比<code>i</code>要大，因此<code>p[i]=p[2*cid-j]</code>明显不成立，但是由于<code>j</code>半径已经越过左边界，根据对称原则<code>i</code>的右边界可以到达右边界<code>mR</code>，也就是说可以得出<code>p[i]=mR-i+1</code><br></li></ul></li> <li>假如<code>i&gt;mR</code>，这就简单了，赋值当前半径为1，继续使用中心扩展去左右扩展匹配<br></li> <li>根据以上两点，总结出以下代码:<br> <code>p[i] = i &lt; mR ? Math.min(p[2 * cId - i], mR - i + 1) : 1;</code><br></li> <li>当计算完<code>p[i]</code>后就要判断当前<code>i</code>的半径是否超过<code>mR</code>，超过则更新<code>mR</code>和<code>cid</code></li></ul> <h4 id="时间复杂度分析"><a href="#时间复杂度分析" aria-hidden="true" class="header-anchor">#</a> 时间复杂度分析</h4> <p>为什么说Manacher的时间复杂度是<code>O(n)</code>，下面可以分析下</p> <p>假设字符串长度为<code>n</code></p> <p>首先把Manacher的核心代码提炼出来大概就是下面这段了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> slen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">&lt;</span> mostR <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> cId <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span> mostR <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> slen <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当<code>i&lt;mR</code>：</p> <ul><li>当<code>p[mR-i+1]!=p[j]</code>时，<code>p[i]</code>都是可以马上得到的，因为进入while循环后就会退出，时间复杂度是<code>O(1)</code>，为什么是<code>O(1)</code>，分两种情况讨论，如下：
<ul><li><code>p[mR-i+1]&gt;p[j]</code>时，如下图：
<img src="/LeetCode/assets/img/0005-15.0378bbe6.png" alt="0005-15.png"><br>
这种情况<code>p[j]</code>小于<code>p[mR-i+1]</code>，所以<code>p[i]</code>会直接取<code>p[j]</code>的值，进入while循环后也不会继续计算</li> <li><code>p[mR-i+1]&lt;p[j]</code>，如下图：
<img src="/LeetCode/assets/img/0005-14.98c6fc2c.png" alt="0005-14.png"><br>
而这种同理，虽然右子串<code>childR</code>到达<code>mR</code>，但是进入while循环就会退出，因为如果可以继续计算的话大概就是下面这样
<img src="/LeetCode/assets/img/0005-17.8f0353a5.png" alt="0005-17.png"><br>
但其实这种情况是不可能出现的，因为这个时候<code>mR</code>早已是最右侧的<code>k</code>，也就是<code>p[mR-i+1]=p[j]</code></li></ul></li> <li>当<code>p[mR-i+1]=p[j]</code>时，进入while循环后会继续匹配，开始匹配的位置是<code>str[i+p[i]]</code>和<code>str[i-p[i]]</code>，因为<code>i+p[i]=mR+1</code>，也就是匹配从<code>mR</code>的下一位开始，而匹配结束时停止的位置是<code>mR'</code>，时间复杂度是<code>O(mR'-mR)</code> <ul><li>这里要注意当每次<code>i&lt;mR</code>&amp;&amp;<code>p[mR-i+1]===p[j]</code>时进入while循环，而<code>mR</code>是一直往后移动的，所以<code>mR</code>小于等于<code>n</code>，全部while循环加起来最多走过<code>n</code>次
<img src="/LeetCode/assets/img/0005-16.0265efd2.png" alt="0005-16.png"><br></li></ul></li></ul> <p>当<code>i&gt;mR</code>，直接进入while循环，同理最多全部循环最多<code>n</code>次，时间复杂度最大为<code>O(n)</code></p> <p>总结来说while循环是对mR进行扩展，如果说最长回文串到达N，那全部while循环加起来最多执行N次，因此Manacher算法时间复杂度为<code>On</code></p> <h2 id="代码实现：中心扩展法"><a href="#代码实现：中心扩展法" aria-hidden="true" class="header-anchor">#</a> 代码实现：中心扩展法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">longestPalindrome</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>
    <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">extendPalindrome</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">===</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            l<span class="token operator">--</span><span class="token punctuation">;</span>
            r<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxLen <span class="token operator">&lt;</span> r <span class="token operator">-</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            start <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            maxLen <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">extendPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">extendPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> maxLen<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="代码实现：manacher算法"><a href="#代码实现：manacher算法" aria-hidden="true" class="header-anchor">#</a> 代码实现：Manacher算法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">longestPalindrome</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        str <span class="token operator">+=</span> <span class="token template-string"><span class="token string">`#</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    str <span class="token operator">+=</span> <span class="token string">'#'</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> slen <span class="token operator">=</span> str<span class="token punctuation">.</span>length<span class="token punctuation">,</span>
        p <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>slen<span class="token punctuation">)</span><span class="token punctuation">,</span>
        mostR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        cId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        palLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
        palStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> slen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">&lt;</span> mostR <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> cId <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span> mostR <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> slen <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;</span> mostR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mostR <span class="token operator">=</span> i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            cId <span class="token operator">=</span> i
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;</span> palLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            palLen <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            palStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">-</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/#/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> palStr
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/LeetCode/0004/" class="prev">
          4.寻找两个有序数组的中位数
        </a></span> <span class="next"><a href="/LeetCode/0006/">
          6.Z 字形变换
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/LeetCode/assets/js/app.643ee7bd.js" defer></script><script src="/LeetCode/assets/js/2.126f6435.js" defer></script>
  </body>
</html>
